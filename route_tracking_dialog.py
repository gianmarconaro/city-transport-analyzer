# -*- coding: utf-8 -*-
"""
/***************************************************************************
 route_trackingDialog
                                 A QGIS plugin
 Thesis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-03-14
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Gianmarco Naro
        email                : gianmarco.naro@mail.polimi.it
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

from qgis.PyQt.QtWidgets import QFileDialog
from qgis.PyQt.QtCore import pyqtSlot

from qgis.core import Qgis, QgsProject

from qgis.utils import iface

from pathlib import Path

import shutil
import zipfile
import sqlite3
import csv


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'route_tracking_dialog_base.ui'))

class route_trackingDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(route_trackingDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.pushButton.clicked.connect(self.on_click)
        self.closeButton.clicked.connect(self.on_click_close)
        self.forwardButton.clicked.connect(self.on_click_forward)
        self.polygonButton.clicked.connect(self.on_click_polygon)

        self.result = False

    # Create a function to open the file dialog and save it in the plugin folder
    def openFileDialog(self):
        # Dialog title
        title = "Select GTFS Data"

        # Starting path
        desktop_path = os.path.join(Path.home(), "Desktop")
        
        # Set options
        options = QFileDialog.Options()
        options |= QFileDialog.DontConfirmOverwrite
        # options |= QFileDialog.DontUseNativeDialog

        # Set format filters
        filters = "GTFS Data (*.zip)"

        # Open the dialog
        file_name, _ = QFileDialog.getSaveFileName(self, title, desktop_path,
                                                  filters, options=options)

        if file_name:
            return file_name
        else:
            self.close()

    def openFileDialogPolygon(self):
        # Dialog title
        title = "Select City Polygons"

        # Starting path
        desktop_path = os.path.join(Path.home(), "Desktop")
        
        # Set options
        options = QFileDialog.Options()
        options |= QFileDialog.DontConfirmOverwrite
        # options |= QFileDialog.DontUseNativeDialog

        # Set format filters
        filters = "Polygons data (*.txt)"

        # Open the dialog
        file_name, _ = QFileDialog.getSaveFileName(self, title, desktop_path,
                                                  filters, options=options)

        if file_name:
            return file_name
        else:
            self.close()    

    @pyqtSlot()
    def on_click(self):
        try:
            # Save the file selected by the user
            zip_file = self.openFileDialog()
            self.extract_gtfs_data(zip_file)

            # Check if the file is empty close the dialog 
            while os.stat(zip_file).st_size == 0:
                # Close the file dialog
                self.close()
                
                # Create a message box to inform the user that the file is empty
                messageBox = QtWidgets.QMessageBox(self)
                messageBox.setWindowTitle("Error!")
                messageBox.setText("<b>The file is empty!</b>\nTry with another file")
                messageBox.exec_()

                # Open the file dialog again
                zip_file = self.openFileDialog()

            iface.messageBar().pushMessage("Success!", "GTFS Data successfully imported!", level=Qgis.Success, duration=5)

            # Alternative way
            # Create a message box to inform the user that the file has been imported
            # messageBox = QtWidgets.QMessageBox(self)
            # messageBox.setWindowTitle("Success!")
            # messageBox.setText("GTFS Data successfully imported!")
            # messageBox.exec_()

        except:
            self.close()
            pass

    def on_click_retry(self):
        self.on_click()

    def on_click_close(self):
        self.result = False
        self.close()

    def on_click_forward(self):
        self.result = True
        self.close()

    def on_click_polygon(self):
        if os.path.isfile(os.path.join(os.path.dirname(__file__), 'polygons', 'polygons.txt')):
            os.remove(os.path.join(os.path.dirname(__file__), 'polygons', 'polygons.txt'))

        # delete the drive and pedestrian graphs
        if os.path.isfile(os.path.join(os.path.dirname(__file__), 'graphs', 'drive_graph.graphml')):
            os.remove(os.path.join(os.path.dirname(__file__), 'graphs', 'drive_graph.graphml'))
        if os.path.isfile(os.path.join(os.path.dirname(__file__), 'graphs', 'drive_graph.gpkg')):
            os.remove(os.path.join(os.path.dirname(__file__), 'graphs', 'drive_graph.gpkg'))

        if os.path.isfile(os.path.join(os.path.dirname(__file__), 'graphs', 'pedestrian_graph.graphml')):
            os.remove(os.path.join(os.path.dirname(__file__), 'graphs', 'pedestrian_graph.graphml'))
        if os.path.isfile(os.path.join(os.path.dirname(__file__), 'graphs', 'pedestrian_graph.gpkg')):
            os.remove(os.path.join(os.path.dirname(__file__), 'graphs', 'pedestrian_graph.gpkg'))        

        try:
            file_name = self.openFileDialogPolygon()
            shutil.copy(file_name, os.path.join(os.path.dirname(__file__), 'polygons', 'polygons.txt'))
            print("Polygons successfully imported!")
            iface.messageBar().pushMessage("Success!", "Polygons successfully imported!", level=Qgis.Success, duration=5)
        except Exception as e:
            print(f'Error during the selection of the polygons: {e}')
            return

    def extract_gtfs_data(self, zip_file):

        LAYER_NAME_STOPS = "stops"

        if os.path.isfile(os.path.join(os.path.dirname(__file__), 'GTFS_DB', 'gtfs.db')):
            os.remove(os.path.join(os.path.dirname(__file__), 'GTFS_DB', 'gtfs.db'))

        project = QgsProject.instance()
        if project.mapLayersByName(LAYER_NAME_STOPS):
            project.removeMapLayer(project.mapLayersByName(LAYER_NAME_STOPS)[0])
        
        for file in os.listdir(os.path.join(os.path.dirname(__file__), 'shapefiles')):
            file_path = os.path.join(os.path.join(os.path.dirname(__file__), 'shapefiles'), file)
            try:
                if os.path.isfile(file_path):
                    os.unlink(file_path)
            except Exception as e:
                print(f'Error during the removal of the file {file_path}: {e}')
                return	

        try:
            print("Extraction and importation of GTFS data...")
            # CSV file to extract from the ZIP file
            csv_to_extract = ['shapes.txt', 'stops.txt', 'stop_times.txt', 'trips.txt', 'routes.txt']
            
            # temporary directory
            temp_dir = os.path.join(os.path.dirname(__file__), 'temp_gtfs')
            os.makedirs(temp_dir, exist_ok=True)
            
            # extract the CSV files from the ZIP file to the temporary directory
            with zipfile.ZipFile(zip_file, 'r') as zip_ref:
                for file_name in csv_to_extract:
                    zip_ref.extract(file_name, temp_dir)
            
            # create the database
            db_path = os.path.join(os.path.dirname(__file__), 'GTFS_DB', 'gtfs.db')
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            for file_name in csv_to_extract:
                print(f'Importing {file_name}...')
                with open(os.path.join(temp_dir, file_name), 'r') as file_csv:
                    reader = csv.reader(file_csv)
                    header = next(reader)
                    table_name = file_name.replace('.txt', '')
                    cursor.execute(f'CREATE TABLE IF NOT EXISTS {table_name} ({", ".join(header)})')
                    cursor.executemany(f'INSERT INTO {table_name} VALUES ({", ".join(["?"] * len(header))})', reader)
            
            conn.commit()
            conn.close()
            
            shutil.rmtree(temp_dir)
            
            print("GTFS data successfully imported!")

            return True
        
        except Exception as e:
            print(f'Error during the extraction and importation of GTFS data: {e}')
            return False
        
    def get_result(self):
        return self.result